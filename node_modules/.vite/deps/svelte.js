import {
  uneval
} from "./chunk-L6ZVCPUP.js";
import {
  createContext,
  getAbortSignal,
  getAllContexts,
  getContext,
  get_render_context,
  get_user_code_location,
  hasContext,
  hydratable_clobbering,
  hydratable_serialization_failed,
  lifecycle_function_unavailable,
  setContext,
  ssr_context
} from "./chunk-HXI27PG2.js";
import "./chunk-CGHTGRXR.js";
import {
  experimental_async_required,
  noop,
  run
} from "./chunk-IDNZLU5E.js";
import "./chunk-ID2N6HUJ.js";
import {
  dev_fallback_default
} from "./chunk-SVYPLSM3.js";
import {
  async_mode_flag
} from "./chunk-OHYQYV5R.js";
import "./chunk-BUSYA2B4.js";

// node_modules/svelte/src/internal/server/hydratable.js
function hydratable(key, fn) {
  if (!async_mode_flag) {
    experimental_async_required("hydratable");
  }
  const { hydratable: hydratable2 } = get_render_context();
  let entry = hydratable2.lookup.get(key);
  if (entry !== void 0) {
    if (dev_fallback_default) {
      const comparison = compare(key, entry, encode(key, fn()));
      comparison.catch(() => {
      });
      hydratable2.comparisons.push(comparison);
    }
    return (
      /** @type {T} */
      entry.value
    );
  }
  const value = fn();
  entry = encode(key, value, hydratable2.unresolved_promises);
  hydratable2.lookup.set(key, entry);
  return value;
}
function encode(key, value, unresolved) {
  const entry = { value, serialized: "" };
  if (dev_fallback_default) {
    entry.stack = get_user_code_location();
  }
  let uid = 1;
  entry.serialized = uneval(entry.value, (value2, uneval2) => {
    if (value2 instanceof Promise) {
      const p = value2.then((v) => `r(${uneval2(v)})`).catch(
        (devalue_error) => hydratable_serialization_failed(
          key,
          serialization_stack(entry.stack, devalue_error?.stack)
        )
      );
      p.catch(() => {
      });
      unresolved?.set(p, key);
      p.finally(() => unresolved?.delete(p));
      const placeholder = `"${uid++}"`;
      (entry.promises ??= []).push(
        p.then((s) => {
          entry.serialized = entry.serialized.replace(placeholder, s);
        })
      );
      return placeholder;
    }
  });
  return entry;
}
async function compare(key, a, b) {
  for (const p of a?.promises ?? []) {
    await p;
  }
  for (const p of b?.promises ?? []) {
    await p;
  }
  if (a.serialized !== b.serialized) {
    const a_stack = (
      /** @type {string} */
      a.stack
    );
    const b_stack = (
      /** @type {string} */
      b.stack
    );
    const stack = a_stack === b_stack ? `Occurred at:
${a_stack}` : `First occurrence at:
${a_stack}

Second occurrence at:
${b_stack}`;
    hydratable_clobbering(key, stack);
  }
}
function serialization_stack(root_stack, uneval_stack) {
  let out = "";
  if (root_stack) {
    out += root_stack + "\n";
  }
  if (uneval_stack) {
    out += "Caused by:\n" + uneval_stack + "\n";
  }
  return out || "<missing stack trace>";
}

// node_modules/svelte/src/internal/server/blocks/snippet.js
function createRawSnippet(fn) {
  return (renderer, ...args) => {
    var getters = (
      /** @type {Getters<Params>} */
      args.map((value) => () => value)
    );
    renderer.push(
      fn(...getters).render().trim()
    );
  };
}

// node_modules/svelte/src/index-server.js
function onDestroy(fn) {
  /** @type {SSRContext} */
  ssr_context.r.on_destroy(fn);
}
function createEventDispatcher() {
  return noop;
}
function mount() {
  lifecycle_function_unavailable("mount");
}
function hydrate() {
  lifecycle_function_unavailable("hydrate");
}
function unmount() {
  lifecycle_function_unavailable("unmount");
}
function fork() {
  lifecycle_function_unavailable("fork");
}
async function tick() {
}
async function settled() {
}
export {
  noop as afterUpdate,
  noop as beforeUpdate,
  createContext,
  createEventDispatcher,
  createRawSnippet,
  noop as flushSync,
  fork,
  getAbortSignal,
  getAllContexts,
  getContext,
  hasContext,
  hydratable,
  hydrate,
  mount,
  onDestroy,
  noop as onMount,
  setContext,
  settled,
  tick,
  unmount,
  run as untrack
};
//# sourceMappingURL=svelte.js.map
